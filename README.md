# 核心交易系统

## 项目背景

银行贷款，肯定是先把个人资料提交给银行做一个资料审核，贷钱嘛。资料审核就是交给银行，或者其他机构，审核看看有没有问题。贷中的话就是看你贷多少钱，还款计划，3年，5年之类的。贷后就是，钱用完了，开始还钱了或者说没有还钱要进行催收和征信数据的上报啥的。这个系统就是一个贷后的系统，贷后的系统主要就是说，因为你贷款，肯定绑定银行卡号，贷后就是要还这笔钱，还这笔钱的时候，一期一期的，把这个钱从你的银行卡里面划扣到银行或者资方的一个账号里面。

## 我们公司做的事情

助贷：我们公司主要做的是针对一些征信不是很好的人给他们放贷的，我们给他做担保，我们从中收取一些服务费，后续客户不还钱了，我们会需要给银行还钱，也就是理赔，后面会具体介绍。
这个系统主要就是跟银行打交道的，这个钱从上游核算系统过来，到我们这个系统，会报给银行，银行把这个银行卡里面的钱扣到对应的一个资方账号里面。这个系统主要就是这样的一个功能。

## 系统模块介绍

### 渠道划分和交易报盘模块

#### 数据来源

交易数据全部来源于上游，上游每天会发起批扣，每天会跑定时任务，去数据库里面捞取要还款的数据，通过mq发到我们这个系统，我们首先会把这个数据进行落库，我们和上游系统核算，约定核算流水号作为幂等字段，数据库这个字段作为唯一索引，来防止重复消费，也就是重复扣钱，如果说这个数据在落库的时候，如果这个数据已经有了，那么肯定就会报错，报违反唯一约束的错误，这种异常我们就可以不处理的，对一些之前没有录过库的数据就正常录库,到交易主表（这里面是包含了所有渠道的交易），主表状态为待处理，落库成功，返回核算成功

#### 数据处理（渠道划分模块和交易模块）

1. **数据打批**
   定时任务两分钟一次，捞取数据库五分钟之前，状态为待处理的数据，把这批数据处理为一个批次，同时将批次号记录在批次表，状态是待处理的

2. **渠道划分，并拆单**

   定时任务驱动，将主表的数据通过业务配置的规则划分到对应的渠道里面并进行拆单（渠道一般两张表，主表和明细表，一对多的关系）
   定时任务两分钟一次捞取待处理的批次表中的批次号，程序中结合业务人员在后台管理页面配置的，渠道划分规则，比如，银行限额，银行是否在维护是否需要签约，一次签约还是每次交易都要进行签约等一系列规则，最终把交易划分到具体的某个渠道里面。
   因为这个系统背后对接了很多的渠道，比如直连银行类，农行，建行，工行，还有就是第三方支付机构。那我们首先会根据业务，配置一些规则，比如这个银行在某个时间段需要维护，那交易就不能提交到这个银行，或者这个银行有一个限额要求。这是打批的一个定时任务个日限额多少钱，月限额多少钱。如果你这笔单比较大的话，就需要拆单，或者直接不走还要就是渠道划分，有很多批次号，批次有一张表，状态也是待处理，捞这个批次表，然后根据批次进行渠道划分，渠道划分的过程中，就会去结合规则，就是配置规则，限额了等等，最终会划分到具体的一个渠道，比如划分到农行渠道，如果这笔交易比较大，会分成两张表张图表，一张明细表(就是银行会有限额要求，就将主单拆成明细单，每个明细的最大金额肯定是不能超过银行的金额)。

3. **交易报盘**
   第三个任务就是交易报盘，把明细表状态待处理的数据捞出来，在代码中进行一些字段处理后报盘给到银行，报盘的意思就是说把这笔交易按银行的加密规则发送到银行那边，银行那边后续流程比较长，比如当时不能拿到交易结果，可能就是交易中。

4. **交易结果查询**

   时间也是两分钟一次，捞取一些交易未明确的状态的数据，去调用银行的交易查询把交易状态结果查回来，把金额和状态更新到明细表中。

5. **交易结果汇总，并返回上游**
   定时任务驱动，此时交易结果还在明细表里面，还没在主表里面，此时会把这些明细表的数据里一个主单下所有明细数据都是终态的数据金额和状态汇总到渠道的主表和刚进来的大表里面，最终把这笔数据结果给核算，这个流程就算走完了，

   **以上五步是我们系统的逻辑**，下面是这句话是上游核算系统要做的一些事情，了解就行

   上游核算会进行对应一些后续的逻辑处理，比如，还款计划的更新之类的，就告诉这个人，交易的结果，成功或者失败，如果客户没有还的话，就会有催收打电话，后续核算的这点流程就跟我们系统没有关系。

### 签约

背景：想从这个客户的卡上扣到钱，必须要先让客户同意签约，拿生活中的举例：你现在把你的银行卡绑定到支付宝上，你输入完个人信息，会发一条验证码的短信到你的手机上，告诉你的银行卡要绑定到支付宝，进行扣款啥的操作，你输入短信验证码，就可以进行绑定的，后续就可以进行扣款操作了。原本的写法是我们在程序中先判断不为空，在进行规则校验，代码复用性不好，后续接入其他直连银行时，这个注解可以复用的

### 充值

#### 背景

我们公司作为担保方，有一些人征信不达标，去银行借不到钱，此时来公司，我们做担保，去给他放贷，我们收取服务费，那存在这种场景，客户不还钱，资方（银行）肯定不能亏钱，此时我们作为担保方，就要钱还给给到银行，后续我们找客户进行追偿（知道就行，我们系统不负责）

**实现逻辑**

充值其实也就是把钱从一个账户扣到另外一个账户，这种和前面那种交易数据其实是一样的，只是收款方和付款方不一样而已，所以本质没有啥区别的，

这个理赔的账户，资金达到小于某个值，就会触发充值的交易过来。

### 理赔

结合上面的充值的业务就是从我们的理赔的账号的钱划扣到资方的那个账号里面，完成还款操作，后续我们债权关系就发生转移了，我们需要找客户还钱了。

## 个人职责

### 职责1

背景：系统比较老，当时用的框架比较老，ibatis，就要去升级成mybatis

这种系统比较老，当时用的框架比较老，ibatis，就要去升级成mybatis，就需要做一个改造，这个活说起来很简单就是简单的标签替换，没有什么技术含量的，就是比较繁琐，因此交给实习生来做了，你在做的过程中，发现mybatis 里面都有对应的一个替代标签去替换，此时你发现项目 xml 有几十个，一个个对 sql进行修改，比较繁琐，然后我就发现，ibatis 有对应 myabtis 的一个标签，就写一个替换工具，把ibatis的标签替换成mybatis的标签，（实现细节，首先你先对一个sql进行替换，先把对应的文本读取为字符串，然后对字符串进行替换，没问题，就一个xml文件进行替换，也没有问题，就整个文件下的进行替换)。这个时候程序-跑，就把项目里的标签都替换完，提高了一个开发效率。

**这个职责可以用来回复项目中的亮点**，你自己通过自己的实践，将原本比较繁琐的事情，通过程序去处理，自己自主去发现并实现的，这个就非常好的

#### 参考文档

标签替换细节

- mapper里面开头的那一段标签是不同的（这个是上来就要替换的），

- 具体写sql时的一些标签也是不同的，这个地方随便记几个mybatis和ibatis相同用法的标签就行，比如：循环的标签，判空的标签两者的替代品

mybatis常用标签：https://blog.csdn.net/m0_38054145/article/details/81906343

ibatis常用标签：https://blog.csdn.net/earl_yuan/article/details/41743693

简单标签对比：https://blog.csdn.net/u012129558/article/details/106102634

### 职责2

**背景**：公司需要对各个系统之间的调用关系和调用耗时信息和后续拓展做一些接口的鉴权信息进行统计啥的，公司的架构组做了一个sdk工具可以实现拦截调用的请求，抓取我们头信息进行上报，把信息通过MQ发送到他们自己的业务平台并落库，这样在他们的平台就可以看到一些调用的信息了。

**具体实现**：

1. 引入服务治理的jar包，将maven的坐标放到我们的pom中。
2. 需要在项目启动时把他们的相关类加载到spring容器中。
3. 在我们的系统调用其他系统时把相应的信息放入到请求头里面（组名，系统名称，时间戳），这个就包括了http的调用和fegin的调用啥的两种，具体实现下面文档有伪代码。

**详细描述：**参与服务治理，公司里面有架构组，架构组需要对系统进行一个统计，每次调用的时候，就把 http 的一些头信息上报到平台，平台就会看调用链路，耗时，上下游的调用关系。为了方便管理，就需要接入服务治理平台，在 http 接口或 feign 调用的时候，需要把头信息里面加上这个系统，它们的平台，首先我们会加入它们的jar 包，启动的时候，把一些类加载进来，调用的时候把一些头信息赛进去。Jar包里面就会拦载 http 接口，然后去把头信息拿出来，发送到它们的平台。这个地方，系统里面有很多 http接口，那一个个设置头信息比较麻烦，然后就通过一个拦截器，把系统名称一些信息配置好，调用的时候就会拦截，上报给服务治理平台。

#### 参照文档

openFegin拦截器使用，只看头半段就行：https://zhuanlan.zhihu.com/p/528834129

Okhttp拦截器使用：https://blog.csdn.net/u011943534/article/details/119334465

### 职责3

**背景**：接入建行渠道进行扣款

**具体实现逻辑**：

通过AOP绑定自定义注解，通过在切面中写自己的校验规则进行一些字段的校验，我们只需要在要校验的属性（姓名，手机号，银行卡号）上加入这个注解就行的，具体的校验逻辑在切面中进行实现就行，就不需要 if 去判断。其他银行用的时候也可以使用。（具体实现伪代码）

**详细描述：**参与建行直连渠道，直连银行签约部分的开发，对于前端提交过来的我们要对手机号，银行卡号，姓名等信息进行校验，只有合法了，才回去调用银行的签约接口，对于这个校验我们程序中最简单直接的做法就是，先判空再去验证对应的正则表达式，这种方式代码复用性较低，然后你那边通过AOP绑定一个注解，对注解进行前置增强，在切面里进行正则的匹配，符合才会走到我们的方法，不符合，直接返回对应的信息给到前端的。这个注解其他银行也可以适用的。

#### 参考文档

自定义注解的使用
https://blog.csdn.net/weixin_58973530/article/details/130596633?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-130596633-blog-126713640.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-130596633-blog-126713640.235%5Ev43%5Epc_blog_bottom_relevance_base5&utm_relevant_index=14

### 职责4

**背景：**我们对接了很多银行，很多渠道，每次版本发布的时候，测试都要做一次回归测试，主要是把系统中的一些核心功能，再跑一次，验证本次是否又改出问题)，每个版本都要进行，有的时候银行在测试在维护，或者他们的测试不配合，想让他们造一些场景来验证一些东西，合作方的人比较忙或者不配合，我们这边就比较被动的，此时想着我们可以mock银行的返回，完成自闭环，验证我们内部的逻辑。这个功能就是这样的。

实现细节描述：

1. 首先和我们测试约定，我们把上游的核算流水号的后六位作为规则字段，测试会去建一张表，用来配置规则字段和模拟银行返回的mock的文本数据的记录，测试一定是会知道这个交易会划分到那个渠道，并且对应我们的处理是会成功还是失败的。
2. 在各个渠道的最末端加一个开关
   - 开关打开：我们回去截取核算流水号的后六位作为规则字段加上渠道的code去查询数据库测试配置的那个mock数据，去模拟银行的返回（这个功能只在测试环境使用，生产一定是关闭的）
   - 开关关闭：走真实的逻辑，去调用银行，进行返回

**详细描述：**自动化mock功能，我们对接了很多银行，很多渠道，每次调用的时候，都要做一次回归测陆(系统改造了，把系统中的一些功能，再跑一次)回归每个版本都要进行，但银行在维护，或者其他什么事情，不配合，卡住了。这个功能就是去模拟银行的返回，因为知道它们参数返回是什么样的，现在就模拟它们的返回，模拟一些场景。正常一笔数据的明细表调出去，就有一个 mock的开关，把开关一开，这个功能是和测试用的，在测试环境的时候，把开关打开，进行调整。通过流水号后6位和渠道code查到测试配置的mock对应的返回的数据程序中，然后程序去跑，金额计算啥的，验证程序的逻辑。

#### 表字段信息

| id（主键） | channel_code（渠道码值） | rule_code（规则字段） | mock_msg（模拟返回文本） | flag（程序处理标志） | create_by | create_date | update_by | update_date |
| ---------- | ------------------------ | --------------------- | ------------------------ | -------------------- | --------- | ----------- | --------- | ----------- |
| 1          | CCB_Direct               | 123123                |                          | S                    |           |             |           |             |



